/**
 * XML Tool Parser for new format
 * 
 * Parses tool calls in the format:
 * <invoke name="tool_name">
 * <parameter name="param">value</parameter>
 * </invoke>
 * 
 * The parser looks for <invoke> tags directly. It does NOT
 * parse any other function call formats or function_calls wrappers.
 * 
 * This parser is designed to match the behavior of the backend XML parser
 * in backend/core/agentpress/xml_tool_parser.py
 * 
 * NOTE: function_calls tags are NOT supported and are ignored.
 */

export interface ParsedToolCall {
  functionName: string; // Function name with underscores converted to hyphens for display
  functionNameRaw: string; // Original function name from XML (with underscores)
  parameters: Record<string, any>;
  rawXml: string; // The full <invoke>...</invoke> block
  parsingDetails?: Record<string, any>; // Additional parsing metadata for compatibility
}

/**
 * Parse XML invoke tags from content string.
 * 
 * This function only parses <invoke> tags, not function calls.
 * Matches the backend parser's behavior in xml_tool_parser.py
 */
export function parseXmlToolCalls(content: string): ParsedToolCall[] {
  const toolCalls: ParsedToolCall[] = [];
  const processedXml = new Set<string>(); // Track processed XML strings to avoid duplicates

  // First, find invoke tags directly in the content (primary method)
  const invokeRegex = /<invoke\s+name=["']([^"']+)["']>([\s\S]*?)<\/invoke>/gi;
  let invokeMatch;
  
  while ((invokeMatch = invokeRegex.exec(content)) !== null) {
    const rawXml = invokeMatch[0];
    
    // Skip if we've already processed this exact XML
    if (processedXml.has(rawXml)) {
      continue;
    }
    
    processedXml.add(rawXml);
    
    const functionNameRaw = invokeMatch[1]; // Keep original name with underscores
    const functionName = functionNameRaw.replace(/_/g, '-'); // Convert to hyphens for display
    const invokeContent = invokeMatch[2];
    const parameters: Record<string, any> = {};
    const rawParameters: Record<string, string> = {}; // Track raw parameter values
    
    // Match parameter blocks (case-insensitive, handles whitespace and quotes)
    const paramRegex = /<parameter\s+name=["']([^"']+)["']>([\s\S]*?)<\/parameter>/gi;
    let paramMatch;
    
    // DEBUG: Log raw invoke content before parsing parameters (safely)
    try {
      console.log('[XML-PARSER] Parsing parameters from invoke content:', {
        functionName: functionNameRaw,
        invokeContent: invokeContent.substring(0, 300) + (invokeContent.length > 300 ? '...' : ''),
        invokeContentLength: invokeContent.length,
      });
    } catch (e) {
      console.log('[XML-PARSER] Parsing parameters for:', functionNameRaw);
    }
    
    while ((paramMatch = paramRegex.exec(invokeContent)) !== null) {
      const paramName = paramMatch[1];
      const paramValue = paramMatch[2]; // Don't trim yet, parseParameterValue will handle it
      
      // DEBUG: Log each parameter as it's found (safely, limit value length)
      try {
        const safeValue = typeof paramValue === 'string' 
          ? (paramValue.length > 100 ? paramValue.substring(0, 100) + '...' : paramValue)
          : paramValue;
        console.log(`[XML-PARSER] Found parameter "${paramName}":`, {
          rawValueLength: typeof paramValue === 'string' ? paramValue.length : 'N/A',
          trimmedValue: typeof paramValue === 'string' ? paramValue.trim().substring(0, 100) : paramValue,
          isFlow: paramName.toLowerCase() === 'flow',
        });
      } catch (e) {
        // Silently skip logging if there's an error
      }
      
      // Store raw parameter value for parsing details
      rawParameters[paramName] = paramValue;
      
      // Parse the parameter value (matches backend _parse_parameter_value logic)
      const parsedValue = parseParameterValue(paramValue);
      parameters[paramName] = parsedValue;
    }
    
    // DEBUG: Log if no parameters found
    if (Object.keys(parameters).length === 0) {
      console.warn('[XML-PARSER] No parameters found in invoke tag:', {
        functionName: functionNameRaw,
        invokeContent: invokeContent,
      });
    }
    
    // Build parsing details matching backend format
    const parsingDetails = {
      function_name: functionNameRaw,
      raw_parameters: rawParameters,
    };
    
    const parsedToolCall = {
      functionName,
      functionNameRaw,
      parameters,
      rawXml,
      parsingDetails,
    };
    
    // DEBUG: Log parsed tool calls with all parameters including flow (safely)
    try {
      // Safely serialize parameters - limit string lengths to prevent URL parsing errors
      const safeParams = Object.entries(parameters).reduce((acc, [k, v]) => {
        if (typeof v === 'string') {
          acc[k] = v.length > 100 ? v.substring(0, 100) + '...' : v;
        } else {
          acc[k] = v;
        }
        return acc;
      }, {} as Record<string, any});
      
      console.log('[XML-PARSER] Parsed tool call:', {
        functionName,
        functionNameRaw,
        allParameterKeys: Object.keys(parameters),
        parameterCounts: Object.entries(parameters).map(([k, v]) => ({ 
          key: k, 
          type: typeof v,
          length: typeof v === 'string' ? v.length : 'N/A'
        })),
        hasFlowParameter: 'flow' in parameters,
        flowValue: parameters.flow,
        rawXmlLength: rawXml.length,
      });
    } catch (e) {
      // Silently skip logging if there's an error (e.g., circular reference or URL parsing)
      console.log('[XML-PARSER] Parsed tool call:', functionName, '(logging skipped due to error)');
    }
    
    toolCalls.push(parsedToolCall);
  }
  
  // DEBUG: Log summary
  if (toolCalls.length > 0) {
    console.log(`[XML-PARSER] Total tool calls parsed: ${toolCalls.length}`, toolCalls.map(tc => ({
      name: tc.functionName,
      hasFlow: 'flow' in tc.parameters,
      flow: tc.parameters.flow,
      paramKeys: Object.keys(tc.parameters),
    })));
  }
  
  return toolCalls;
}

/**
 * Parse a parameter value, attempting to convert to appropriate type.
 * Matches the backend's _parse_parameter_value method behavior:
 * 1. Try JSON parsing if starts with { or [
 * 2. Try boolean if 'true' or 'false'
 * 3. Try number (float if contains ., otherwise int)
 * 4. Return as string otherwise
 */
function parseParameterValue(value: string): any {
  const trimmed = value.trim();
  
  // Try to parse as JSON first (matches backend behavior)
  if (trimmed.startsWith('{') || trimmed.startsWith('[')) {
    try {
      return JSON.parse(trimmed);
    } catch {
      // If JSON parsing fails, continue with other type checks
    }
  }
  
  // Try to parse as boolean (matches backend behavior - case-insensitive)
  if (trimmed.toLowerCase() === 'true') return true;
  if (trimmed.toLowerCase() === 'false') return false;
  
  // Try to parse as number (matches backend behavior)
  // Check if it's a valid number string
  if (/^-?\d+(\.\d+)?([eE][+-]?\d+)?$/.test(trimmed)) {
    const num = parseFloat(trimmed);
    if (!isNaN(num)) {
      // If it contains a decimal point or scientific notation, return as float
      // Otherwise return as int (matching backend behavior)
      if (trimmed.includes('.') || /[eE]/.test(trimmed)) {
        return num;
      } else {
        return parseInt(trimmed, 10);
      }
    }
  }
  
  // Return as string if no type conversion succeeded
  return value;
}

export function extractToolName(content: string): string | null {
  if (isNewXmlFormat(content)) {
    const toolCalls = parseXmlToolCalls(content);
    if (toolCalls.length > 0) {
      return toolCalls[0].functionName.replace(/_/g, '-');
    }
  }
  
  const xmlRegex = /<([a-zA-Z\-_]+)(?:\s+[^>]*)?>(?:[\s\S]*?)<\/\1>|<([a-zA-Z\-_]+)(?:\s+[^>]*)?\/>/;
  const match = content.match(xmlRegex);
  if (match) {
    const toolName = match[1] || match[2];
    return toolName.replace(/_/g, '-');
  }
  
  return null;
}

export function isNewXmlFormat(content: string): boolean {
  // Check for invoke tags directly (new format)
  return /<invoke\s+name=/.test(content);
}

export function extractToolNameFromStream(content: string): string | null {
  const invokeMatch = content.match(/<invoke\s+name=["']([^"']+)["']/i);
  if (invokeMatch) {
    return invokeMatch[1].replace(/_/g, '-');
  }

  const oldFormatMatch = content.match(/<([a-zA-Z\-_]+)(?:\s+[^>]*)?>(?!\/)/);
  if (oldFormatMatch) {
    return oldFormatMatch[1].replace(/_/g, '-');
  }
  
  return null;
}

export function formatToolNameForDisplay(toolName: string): string {
  if (toolName.startsWith('mcp_')) {
    const parts = toolName.split('_');
    if (parts.length >= 3) {
      const serverName = parts[1];
      const toolNamePart = parts.slice(2).join('_');
      const formattedServerName = serverName.charAt(0).toUpperCase() + serverName.slice(1);
      
      let formattedToolName = toolNamePart;
      if (toolNamePart.includes('-')) {
        formattedToolName = toolNamePart
          .split('-')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
      } else if (toolNamePart.includes('_')) {
        formattedToolName = toolNamePart
          .split('_')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
      } else {
        formattedToolName = toolNamePart.charAt(0).toUpperCase() + toolNamePart.slice(1);
      }
      
      return `${formattedServerName}: ${formattedToolName}`;
    }
  }
  
  return toolName
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
} 